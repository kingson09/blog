java代码通过类加载器加载dex加载，由于android没有i### 20180410
今天听闻Android P开始限制私有API的访问权限，这导致我们项目的基础架构插件框架无法使用，思考其影响，其他的都好说，最重要的是资源加载这块，可以说一个apk的代码分为两种，java代码和xml这种dsl代码，java代码通过类加载器加载dex加载，由于android没有ios的类加载限制，签名校验自己负责，因此java代码加载目前没有问题，而视图代码也就是resource那部分就不同了，使用AssertManager加载，由于android studio相比ios的开发工具好用很多，所以开发视图方面不像ios，android基本都是用xml这种dsl模板开发，这导致如果限制资源加载，那么庞大的视图代码无法动态加载，头疼，本来处理context代理以及资源id固定已经让插件机制十分脆弱，现在更是雪上加霜
### 20180420
今天尝试使用伪造android包名的方式访问framework中的protected或者default属性和成员，失败，查找原因[JVM对于不同classLoader加载的对象之间default或protected字段存在访问限制](https://www.iflym.com/index.php/code/jvm-constraint-for-default-or-protected-field-between-classloaders.html)，也就是说这两个字段的真正意义在于，保护JRE或者art中的类访问权限，只能说自己太naive了
### 20180421
[“Java泛型有这么一种规律： 
位于声明一侧的，源码里写了什么到运行时就能看到什么； 
位于使用一侧的，源码里写什么到运行时都没了”
——RednaxelaFX](http://rednaxelafx.iteye.com/blog/586212)

吐血，再吐三公升血
### 20180421
不得不说，网络上的技术水文到了影响别人学习的地步，差点的是虎头蛇尾，说一通网上到处都是的技术点，文章不是文章，笔记不是笔记，好点的是人云亦云，写一堆别人都写烂的东西，搜一个知识点，写的内容都一样，真是不明白这些人怎么那么多时间，刷这些水文
### 20180422
今天做个小需求，要在Activity启动的时候弹个浮层，用到了多年不用的PopupWindow和View.post()方法，想起了以前用View.post()是为了获得控件高度，但仔细想了想，ActivityThread在handleLaunchActivity、handleResumeActivity这两个同步操作之后，只是把view add到WMS中，真正的测绘需要Choreographer下一个Vsync同步信号到来时才会执行，虽然ViewRootImpl加入了SyncBarrier，但那么View.post()是在加入屏障之前的任务，不会受到屏障影响，View.post放入handler的任务应该在测绘之前就执行了啊，不解，遂先Google之实在不行再看代码，[果然有细心的同学已经研究过了](http://androidperformance.com/2015/12/29/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E4%B8%80%E7%A7%8DDelayLoad%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86-%E4%B8%8B%E7%AF%87.html)，我一直以为View.post只是把任务简单抛到主线程的handler，原来并没有那么简单，View.post是委托给ViewRootImpl做了更多的同步操作，这位同学是一个细心认真的同学，不过有一点写错了，performTraversals一开始确实会执行两次，但都是同步的，和executeActions里面那个Post无关，那个post只是为了在同步任务执行完毕后执行。

今天写的多点，[看到一篇文章](https://blog.csdn.net/cdecde111/article/details/54670136)，这篇文章的作者是个不错的同学，利用SyncBarrier实现预加载，还在github上实现了完整的tools，但这位同学把这件事情弄复杂了，实际上新页面的ContentView add到WMS的时候已经加入了同步屏障，你在onCreate或者onResume里面发起的异步加载数据请求，最终都是要把返回结果跑到handler去渲染的，而这些同步渲染任务肯定会在屏障解除之后才能执行，所以这些任务天然就是预加载并且做过同步，这个同学在Activity之前就加入了屏障，只能导致这个屏障之后的同步任务都要等待数据请求返回，反而把并行搞成了串行，起了反作用，还有[Bugly公众号推荐的这个文章](https://mp.weixin.qq.com/s/KpeBqIEYeOzt_frANoGuSg)，也犯了类似的错误，没注意Google早就给测绘准备了SyncBarrier，不用你操心