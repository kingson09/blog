### 20180410
今天听闻Android P开始限制私有API的访问权限，这导致我们项目的基础架构插件框架无法使用，思考其影响，其他的都好说，最重要的是资源加载这块，可以说一个apk的代码分为两种，java代码和xml这种dsl代码，java代码通过类加载器加载dex加载，由于android没有ios的类加载限制，签名校验自己负责，因此java代码加载目前没有问题，而视图代码也就是resource那部分就不同了，使用AssertManager加载，由于android studio相比ios的开发工具好用很多，所以开发视图方面不像ios，android基本都是用xml这种dsl模板开发，这导致如果限制资源加载，那么庞大的视图代码无法动态加载，头疼，本来处理context代理以及资源id固定已经让插件机制十分脆弱，现在更是雪上加霜
### 20180420
今天尝试使用伪造android包名的方式访问framework中的protected或者default属性和成员，失败，查找原因[JVM对于不同classLoader加载的对象之间default或protected字段存在访问限制](https://www.iflym.com/index.php/code/jvm-constraint-for-default-or-protected-field-between-classloaders.html)，也就是说这两个字段的真正意义在于，保护JRE或者art中的类访问权限，只能说自己太naive了
### 20180421
[“Java泛型有这么一种规律： 
位于声明一侧的，源码里写了什么到运行时就能看到什么； 
位于使用一侧的，源码里写什么到运行时都没了”
——RednaxelaFX](http://rednaxelafx.iteye.com/blog/586212)

吐血，再吐三公升血
### 20180421
不得不说，网络上的技术水文到了影响别人学习的地步，差点的是虎头蛇尾，说一通网上到处都是的技术点，文章不是文章，笔记不是笔记，好点的是人云亦云，写一堆别人都写烂的东西，搜一个知识点，写的内容都一样，真是不明白这些人怎么那么多时间，刷这些水文
### 20180422
今天做个小需求，要在Activity启动的时候弹个浮层，用到了多年不用的PopupWindow和View.post()方法，想起了以前用View.post()是为了获得控件高度，但仔细想了想，ActivityThread在handleLaunchActivity、handleResumeActivity这两个同步操作之后，只是把view add到WMS中，真正的测绘需要Choreographer下一个Vsync同步信号到来时才会执行，虽然ViewRootImpl加入了SyncBarrier，但那么View.post()是在加入屏障之前的任务，不会受到屏障影响，View.post放入handler的任务应该在测绘之前就执行了啊，不解，遂先Google之实在不行再看代码，[果然有细心的同学已经研究过了](http://androidperformance.com/2015/12/29/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E4%B8%80%E7%A7%8DDelayLoad%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86-%E4%B8%8B%E7%AF%87.html)，我一直以为View.post只是把任务简单抛到主线程的handler，原来并没有那么简单，View.post是委托给ViewRootImpl做了更多的同步操作，这位同学是一个细心认真的同学，不过有一点写错了，performTraversals一开始确实会执行两次，但都是同步的，和executeActions里面那个Post无关，那个post只是为了在同步任务执行完毕后执行。

今天写的多点，[看到一篇文章](https://blog.csdn.net/cdecde111/article/details/54670136)，这篇文章的作者是个不错的同学，利用SyncBarrier实现预加载，还在github上实现了完整的tools，但这位同学把这件事情弄复杂了，实际上在onCreate或者onResume里本来就是要让你加载数据的，你把数据加载了，后面的测绘(layout measure draw)才不会在数据加载完后再重复执行，并且异步数据请求，最终都是要抛到handler任务队列里，既然都是要抛到主线程队列，那么在onCreate这样一个方法内部再做preload、readload岂不是多此一举，你只要load，数据返回时自然onCreate之类的已经执行完毕了，如果说要在startActivity之前做预加载，那么做个双向观察者就可以了，还有[Bugly公众号推荐的这个文章](https://mp.weixin.qq.com/s/KpeBqIEYeOzt_frANoGuSg)，在向Choreographer post一个Vsync回调帧之后，要等到Vsync到来才会往handler中post一个测绘任务，在这中间handler中的msg queue如果空闲，就会先执行idleHandler，当然由于文章中的数据请求本身就是异步任务，所以addIdleHandler只有极特殊情况下才会先于Vsync信号执行，或者说在Vsync回调之前msg queue根本不会为空，但Choreographer的postFrameCallback确实不等同于handler.post,因为回调帧本身就是异步任务，其实google在测绘开始前加入SyncBarrier，只要通过View.post或者handler.post(post())是可以达到绘制完成的回调效果的,可以这么说View.post是回调view绘制完成的最佳手段
### 20180422
Window.Callback 有意思 :)